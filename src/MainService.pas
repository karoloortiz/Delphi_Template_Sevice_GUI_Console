unit MainService;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.SvcMgr, Vcl.Dialogs,
  KLib.MyThread, KLib.Windows.EventLog;

type
  TMyService = class(TService)
    procedure ServiceContinue(Sender: TService; var Continued: Boolean);
    procedure ServicePause(Sender: TService; var Paused: Boolean);
    procedure ServiceCreate(Sender: TObject);
    procedure ServiceAfterInstall(Sender: TService);
    procedure ServiceAfterUninstall(Sender: TService);
    procedure ServiceShutdown(Sender: TService);
    procedure ServiceStop(Sender: TService; var Stopped: Boolean);
    procedure ServiceDestroy(Sender: TObject);
    procedure ServiceStart(Sender: TService; var Started: Boolean);
  private
    workerThread: TMyThread;
    eventLog: TEventLog;
  protected
    procedure rejectCallback(msg: string);
  public
    function GetServiceController: TServiceController; override;
    { Public declarations }
  end;

var
  MyService: TMyService;

implementation

{$r *.dfm}


uses
  Env,
  Application,
  KLib.Windows, KLib.Utils, KLib.Constants,
  System.Win.Registry;

procedure TMyService.rejectCallback(msg: string);
var
  _fileName: string;
  _logMessage: string;
begin
  _fileName := getCombinedPathWithCurrentDir('log.txt');
  _logMessage := 'ERROR -> ' + msg;
  appendToFile(_fileName, _logMessage, FORCE_CREATION);
  eventLog.writeError(_logMessage);
end;

procedure TMyService.ServiceCreate(Sender: TObject);
begin
  DisplayName := SERVICE_NAME;
  eventLog := TEventLog.Create(APPLICATION_NAME);
end;

procedure TMyService.ServiceStart(Sender: TService; var Started: Boolean);
begin
  Started := False;
  try
    workerThread := TMyThread.Create(myJob, rejectCallback);
    eventLog.writeInfo('Service has been started.');
    Started := True;
  except
    on E: Exception do
    begin
      rejectCallback('Service failed to start :' + E.Message);
    end;
  end;
end;

procedure TMyService.ServiceContinue(Sender: TService; var Continued: Boolean);
begin
  workerThread.myResume;
  Continued := True;
  eventLog.writeInfo('Service has been resumed.');
end;

procedure TMyService.ServicePause(Sender: TService; var Paused: Boolean);
begin
  workerThread.pause;
  Paused := True;
  eventLog.writeInfo('Service has been paused.');
end;

procedure TMyService.ServiceShutdown(Sender: TService);
var
  Stopped: boolean;
begin
  ServiceStop(Self, Stopped);
end;

procedure TMyService.ServiceStop(Sender: TService; var Stopped: Boolean);
begin
  try
    Stopped := True; // always stop service, even if we had exceptions, this is to prevent "stuck" service (must reboot then)

    workerThread.stop;
    while WaitForSingleObject(workerThread.Handle, WaitHint - 100) = WAIT_TIMEOUT do
    begin
      ReportStatus;
    end;
    FreeAndNil(workerThread);

    eventLog.writeInfo('Service has been stopped.');
  except
    on E: Exception do
    begin
      rejectCallback('Service failed to stop :' + E.Message);
    end;
  end;
end;

procedure TMyService.ServiceAfterInstall(Sender: TService);
begin
  writeIn_HKEY_LOCAL_MACHINE(SERVICE_REGKEY, 'Description', SERVICE_NAME_DESCRIPTION);
  TEventLog.addEventApplicationToRegistry(APPLICATION_NAME, exeFileName);
end;

procedure TMyService.ServiceAfterUninstall(Sender: TService);
begin
  TEventLog.deleteEventApplicationFromRegistry(APPLICATION_NAME);
end;

procedure TMyService.ServiceDestroy(Sender: TObject);
begin
  FreeAndNil(eventLog)
end;

//##############################################################################
procedure ServiceController(CtrlCode: DWord); stdcall; //generated by default
begin
  MyService.Controller(CtrlCode);
end;

function TMyService.GetServiceController: TServiceController; //generated by default
begin
  Result := ServiceController;
end;

end.
